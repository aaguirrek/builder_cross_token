{"version":3,"file":"js/28.93064e50.js","mappings":"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","sources":["webpack://quant-ux/./src/dash/Heat.vue","webpack://quant-ux/src/dash/Heat.vue","webpack://quant-ux/./src/dash/Heat.vue?f898","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue","webpack://quant-ux/src/views/apps/test/VideoPlayer.vue","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue?b15e","webpack://quant-ux/./src/views/apps/test/VideoPlayer.vue?cc80"],"sourcesContent":["var render, staticRenderFns\nimport script from \"./Heat.vue?vue&type=script&lang=js\"\nexport * from \"./Heat.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n<script>\nimport DojoWidget from \"dojo/DojoWidget\";\nimport _Color from \"common/_Color\";\n\nexport default {\n  name: \"Heat\",\n  mixins: [_Color, DojoWidget],\n  data: function () {\n    return {\n      defaultRadius: 15,\n      defaultBlur: 20,\n      defaultGradient: {\n        0.4: \"blue\",\n        0.6: \"cyan\",\n        0.7: \"lime\",\n        0.8: \"yellow\",\n        \"1.0\": \"red\",\n      },\n      max: -1,\n    };\n  },\n  components: {},\n  methods: {\n    computeMouseDistribution(events, model) {\n      var result = {};\n      /**\n       * Sort by screen\n       */\n      var screens = {};\n      for (let i = 0; i < events.length; i++) {\n        let event = events[i];\n        if (!screens[event.screen]) {\n          screens[event.screen] = [];\n        }\n        screens[event.screen].push(event);\n      }\n\n      /**\n       * 1) for each screen\n       */\n      for (let id in screens) {\n        var screenModel = model.screens[id];\n        if (screenModel) {\n          /**\n           * 2) Loop over all events and build one array\n           */\n          var screenEvents = screens[id];\n          var temp = [];\n          for (let i = 0; i < screenEvents.length; i++) {\n            /**\n             * 2.a) Loop over all mouse position in the event.\n             */\n            let event = screenEvents[i];\n            var xs = event.x;\n            var ys = event.y;\n            var ts = event.t;\n            for (let j = 0; j < xs.length; j++) {\n              temp.push({\n                x: xs[j],\n                y: ys[j],\n                t: ts[j],\n              });\n            }\n          }\n\n          /**\n           * 2.b) sort by time\n           */\n          temp.sort(function (a, b) {\n            return a.t - b.t;\n          });\n\n          /**\n           * 3)  build matrix\n           */\n          var width = screenModel.w;\n          var height = screenModel.h;\n\n          var lastT = 0;\n          var m = {};\n          var max = -1;\n\n          for (let i = 0; i < temp.length; i++) {\n            var e = temp[i];\n            var tDif = 0;\n\n            if (lastT > 0) {\n              tDif = Math.log(e.t - lastT);\n            }\n\n            if (lastT > e.t) {\n              console.error(\"wrong order\", i, e.t);\n            }\n\n            /**\n             * 4) Build matrix with tDif as intensity\n             */\n            if (e.x > 0 && e.y > 0) {\n              var x = Math.round(e.x * width);\n              var y = Math.round(e.y * height);\n\n              if (m[x] == null) {\n                m[x] = {};\n              }\n              if (m[x][y] == null) {\n                m[x][y] = 0;\n              }\n              m[x][y] += tDif;\n\n              max = Math.max(max, m[x][y]);\n            }\n\n            lastT = e.t;\n          }\n\n          result[id] = {\n            max: max,\n            values: this._matrixToData(m),\n          };\n        } else {\n          console.debug(\"No Screen Model for \", id);\n        }\n      }\n\n      return result;\n    },\n\n    /***********************************************************\n     *  Click\n     ***********************************************************/\n\n    computeClickDistribution(value, width, height) {\n      var m = {};\n      var max = -1;\n      for (var i = 0; i < value.length; i++) {\n        var e = value[i];\n\n        if (e.x && e.y && !e.noheat) {\n          var x = Math.round(e.x * width);\n          var y = Math.round(e.y * height);\n          if (x > 0 && y > 0) {\n            if (m[x] == null) {\n              m[x] = {};\n            }\n            if (m[x][y] == null) {\n              m[x][y] = 0;\n            }\n            m[x][y]++;\n\n            max = Math.max(max, m[x][y]);\n          }\n        }\n      }\n\n      return {\n        max: max,\n        values: this._matrixToData(m),\n      };\n    },\n\n    /**\n     * convert sparse matrix to dense matrix that is needed for rendering\n     */\n    _matrixToData(m) {\n      var data = [];\n      for (var x in m) {\n        var row = m[x];\n        for (var y in row) {\n          var pos = [];\n          pos[0] = x;\n          pos[1] = y;\n          pos[2] = m[x][y];\n          data.push(pos);\n        }\n      }\n      return data;\n    },\n\n    cleanUpHeat() {\n      delete this._circle;\n    },\n\n    /***************************************************************************************\n     * code inspired by https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js\n     ***************************************************************************************/\n\n    draw: function (ctx, data, max, width, height, minOpacity) {\n\n      if (width <= 0 || height <= 0) {\n        return\n      }\n\n      if (!this._circle) {\n        this.radius(this.defaultRadius, this.defaultBlur);\n      }\n      if (!this._grad) {\n        this.gradient(this.defaultGradient);\n      }\n\n      ctx.clearRect(0, 0, width, height);\n\n      // draw a grayscale heatmap by putting a blurred circle at each data point\n      for (var i = 0, len = data.length, p; i < len; i++) {\n        p = data[i];\n        ctx.globalAlpha = Math.max(\n          p[2] / max,\n          minOpacity === undefined ? 0.05 : minOpacity\n        );\n        ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n      }\n\n      // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n      var colored = ctx.getImageData(0, 0, width, height);\n      this._colorize(colored.data, this._grad);\n      ctx.putImageData(colored, 0, 0);\n    },\n\n    radius: function (r, blur) {\n      blur = blur || 15;\n\n      // create a grayscale blurred circle image that we'll use for drawing points\n      var circle = (this._circle = document.createElement(\"canvas\"));\n      var ctx = circle.getContext(\"2d\");\n      var r2 = (this._r = r + blur);\n\n      circle.width = circle.height = r2 * 2;\n\n      ctx.shadowOffsetX = ctx.shadowOffsetY = 200;\n      ctx.shadowBlur = blur;\n      ctx.shadowColor = \"black\";\n\n      ctx.beginPath();\n      ctx.arc(r2 - 200, r2 - 200, r, 0, Math.PI * 2, true);\n      ctx.closePath();\n      ctx.fill();\n\n      return this;\n    },\n\n    gradient: function (grad) {\n      // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n      var canvas = document.createElement(\"canvas\");\n      var ctx = canvas.getContext(\"2d\");\n      var gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n      canvas.width = 1;\n      canvas.height = 256;\n\n      for (var i in grad) {\n        gradient.addColorStop(i * 1, grad[i]);\n      }\n\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, 1, 256);\n\n      this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n      return this;\n    },\n\n    _colorize: function (pixels, gradient) {\n      for (var i = 3, len = pixels.length, j; i < len; i += 4) {\n        j = pixels[i] * 4; // get gradient color from opacity value\n\n        if (j) {\n          pixels[i - 3] = gradient[j];\n          pixels[i - 2] = gradient[j + 1];\n          pixels[i - 1] = gradient[j + 2];\n        }\n      }\n    },\n\n    /***********************************************************\n     *  Scroll Heat Map Stuff\n     ***********************************************************/\n\n    computeScrollDurationDistrubtion(value, visibleScreenSize, height) {\n      /**\n       * Init heatmap with 0s\n       */\n      var result = [];\n      for (let i = 0; i < height; i++) {\n        result[i] = 1;\n      }\n      var max = 1;\n\n      var lastEventTime = -1;\n      var lastScrollTop = -1;\n      for (let i = 0; i < value.length; i++) {\n        var e = value[i];\n\n        if (e.type == \"SessionStart\") {\n          lastEventTime = -1;\n          lastScrollTop = -1;\n        }\n\n        /**\n         * We are just interested in the ScreenLoaded and ScreenScroll events\n         */\n        if (e.type == \"ScreenScroll\" || e.type == \"ScreenLoaded\") {\n          var scrollTop = 0;\n          if (e.type == \"ScreenScroll\" && e.state && e.state.children) {\n            scrollTop = e.state.value * 1;\n            scrollTop = Math.floor(visibleScreenSize * scrollTop);\n          }\n\n          if (lastEventTime >= 0 && lastScrollTop >= 0) {\n            /**\n             * Now inc for the visible area with the duration\n             */\n            var duration = e.time - lastEventTime;\n\n            for (var j = 0; j < visibleScreenSize; j++) {\n              var r = lastScrollTop + j;\n              if (r < height) {\n                result[r] += duration;\n                max = Math.max(max, result[r]);\n              }\n            }\n          }\n          lastEventTime = e.time;\n          lastScrollTop = scrollTop;\n        }\n      }\n\n      return {\n        max: max,\n        values: result,\n      };\n    },\n\n    computeScrollVisibiltyDistribution(value, visibleScreenSize, height) {\n      /**\n       * Init heatmap with 0s\n       */\n      var result = [];\n      for (let i = 0; i < height; i++) {\n        result[i] = 1;\n      }\n      let max = 1;\n\n      /**\n       * Loop over all events. Just just ScreenLoaded and Scroll events\n       * to update the heapmap.\n       *\n       * We do this by user the concept of a ScreenSession. A ScreenSession includes all events,\n       * from one ScreenLoaded event until the next ScreenLoaded event. We store for each ScreenSession\n       * the max scrollTop value for all events in the session\n       */\n      var lastPageLoad = null;\n      var pageSessions = {};\n      for (let i = 0; i < value.length; i++) {\n        var e = value[i];\n        /**\n         * We are just interested in the ScreenLoaded and ScreenScroll events\n         */\n        if (e.type == \"ScreenScroll\" || e.type == \"ScreenLoaded\") {\n          if (e.type == \"ScreenLoaded\") {\n            lastPageLoad = e.id;\n            if (!pageSessions[lastPageLoad]) {\n              pageSessions[lastPageLoad] = 0;\n            }\n          }\n          var scrollTop = 0;\n          if (e.type == \"ScreenScroll\" && e.state && e.state.children) {\n            scrollTop = e.state.value * 1;\n            scrollTop = Math.floor(visibleScreenSize * scrollTop);\n          }\n          pageSessions[lastPageLoad] = Math.max(\n            scrollTop,\n            pageSessions[lastPageLoad]\n          );\n        }\n      }\n\n      /**\n       * Now we build the final gradient\n       */\n      for (var id in pageSessions) {\n        let scrollTop = pageSessions[id];\n        let to = visibleScreenSize * 1 + scrollTop * 1;\n        for (var j = 0; j < to; j++) {\n          if (j < height) {\n            result[j] += 1;\n            max = Math.max(max, result[j]);\n          }\n        }\n      }\n\n      return {\n        max: max,\n        values: result,\n      };\n    },\n\n    drawSections(dist, ctx, height, width) {\n      this.logger.log(2, \"drawSections\", \"enter\");\n\n      var result = dist.values;\n      if (!ctx) {\n        ctx = this._ctx;\n      }\n\n      if (!width) {\n        width = this._width;\n      }\n\n      if (!height) {\n        height = this._height;\n      }\n\n      if (!dist.max) {\n        console.warn(\"drawSections() > no max\");\n        dist.max = this.max;\n      }\n\n      /**\n       * Now turn to relative values\n       */\n      var lastValue = -1;\n      var lastY = 0;\n\n      ctx.globalAlpha = 0.4;\n      for (let i = 0; i < height; i++) {\n        if (lastValue != result[i] && lastValue >= 0) {\n          let value = lastValue / dist.max;\n          /**\n           * FIXME: get color from gradient!!\n           */\n          let color = this.mixColor(value);\n          ctx.fillStyle = color;\n          var h = i - lastY;\n          ctx.fillRect(0, lastY, width, h);\n          lastY = i;\n        }\n        lastValue = result[i];\n      }\n\n      /**\n       * last section?\n       */\n      var value = lastValue / dist.max;\n      var color = this.mixColor(value);\n      ctx.fillStyle = color;\n      ctx.fillRect(0, lastY, width, height);\n\n      this.logger.log(2, \"drawSections\", \"exit\");\n    },\n  },\n  mounted() {},\n};\n</script>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Heat.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Heat.vue?vue&type=script&lang=js\"","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"MatcPlayer\"},[_c('div',{staticClass:\"MatcPlayerLeft\"},[_c('div',{ref:\"container\",staticClass:\"MatcPlayerView\"}),_c('div',{staticClass:\"MatcPlayerNav\"},[_c('div',{ref:\"tasks\",staticClass:\"MatcPlayerTasks\"}),_c('div',{ref:\"progress\",staticClass:\"MatcPlayerProgress\"})]),_vm._m(0)]),_c('div',{staticClass:\"MatcPlayerEvents\",attrs:{\"data-dojo-attach-point\":\"eventCntr\"}})])\n}\nvar staticRenderFns = [function (){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"MatcPlayerButtonBar\"},[_c('div',{},[_c('a',{attrs:{\"data-dojo-attach-point\":\"btnBack\"}},[_c('span',{staticClass:\"mdi mdi-skip-previous\"})]),_c('a',{attrs:{\"data-dojo-attach-point\":\"btnPlay\"}},[_c('span',{staticClass:\"mdi mdi-play\",attrs:{\"data-dojo-attach-point\":\"iconPlay\"}})]),_c('span',{staticClass:\"MatcPlayerTime\",attrs:{\"data-dojo-attach-point\":\"time\"}})])])\n}]\n\nexport { render, staticRenderFns }","<template>\n     <div class=\"MatcPlayer\">\n\t\t<div class=\"MatcPlayerLeft\">\n\t\t\t<div class=\"MatcPlayerView\" ref=\"container\">\n\t\t\t</div>\n\t\t\t<div class=\"MatcPlayerNav\">\n\t\t\t\t<div class=\"MatcPlayerTasks\" ref=\"tasks\">\n\t\t\t\t</div>\n\t\t\t\t<div class=\"MatcPlayerProgress\" ref=\"progress\">\n\t\t\t\t</div>\n\t\t\t</div>\t\n\t\t\n\t\t\t<div class=\"MatcPlayerButtonBar\">\n\t\t\t\t<div class=\"\">\n\t\t\t\t\t<a data-dojo-attach-point=\"btnBack\"><span class=\"mdi mdi-skip-previous\"></span></a>\n\t\t\t\t\t<a data-dojo-attach-point=\"btnPlay\"><span data-dojo-attach-point=\"iconPlay\" class=\"mdi mdi-play\"></span></a>\n\t\t\t\t\t<span class=\"MatcPlayerTime\" data-dojo-attach-point=\"time\"></span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"MatcPlayerEvents\" data-dojo-attach-point=\"eventCntr\">\n\n\t\t</div>\n\t</div>\n</template>\n<script>\nimport DojoWidget from 'dojo/DojoWidget'\nimport css from 'dojo/css'\nimport on from 'dojo/on'\nimport touch from 'dojo/touch'\nimport lang from 'dojo/_base/lang'\nimport domGeom from 'dojo/domGeom'\nimport Logger from 'common/Logger'\nimport DataFrame from 'common/DataFrame'\nimport HSlider from 'common/HSlider'\nimport DomBuilder from 'common/DomBuilder'\nimport Util from 'core/Util'\nimport RenderFactory from 'core/RenderFactory'\nimport Animation from 'core/Animation'\nimport Analytics from 'dash/Analytics'\nimport Preview from 'page/Preview'\nimport Core from 'core/Core'\nimport Services from 'services/Services'\n\nexport default {\n    name: 'Player',\n\tmixins:[DojoWidget, Util],\n\tprops: [\"app\", \"testSettings\", \"annotation\", \"sessionID\", \"eventsWithAnnimations\", \"pub\", \"mouse\"],\n    data: function () {\n        return {\n            running: false,\n            currentTime: 0,\n            lastEventPos: 0,\n            animationTimeOffSet: 400,\n            mode: \"private\",\n            invisibleEvents: {\n\t\t\t\t\"Animation\": true,\n\t\t\t\t\"SessionStart\": true,\n\t\t\t\t\"ScreenAnimation\": true,\n\t\t\t\t\"OverlayShowAnimation\": true,\n\t\t\t\t\"OverlayRemoveAnimation\": true,\n\t\t\t\t\"ValidationOk\": true,\n\t\t\t\t\"MouseOut\": true,\n\t\t\t\t\"MouseOver\": true,\n\t\t\t\t\"WidgetInit\": true\n\t\t\t}\n        }\n    },\n\tcomponents: {},\n\n    methods: {\n      postCreate (){\n\t\t\tthis.logger = new Logger('VideoPlayer');\n\t\t\tthis.analytics = new Analytics();\n\t\t\tthis.jwtToken = Services.getUserService().getToken()\n\t\t\tthis.db = new DomBuilder()\n\t\t\tthis.own(on(this.btnBack, touch.press, lang.hitch(this, \"onBack\")));\n\t\t\tthis.own(on(this.btnPlay, touch.press, lang.hitch(this, \"onPlay\")));\n\t\t\tthis.init()\n\t\t},\n\n\t\tinit () {\n\t\t\tif (this.app) {\n\t\t\t\tthis.setModel(this.app)\n\t\t\t\tlet events = this.analytics.nornalizeContainerChildEvents(this.eventsWithAnnimations)\n\t\t\t\tvar df = new DataFrame(events);\n\t\t\t\tvar sessionGroup = df.groupBy(\"session\");\n\t\t\t\tvar session = sessionGroup.get(this.sessionID);\n\t\t\t\tthis.mouseData = this.mouse\n\t\t\t\tthis.setSession(session, this.sessionID)\n\t\t\t}\n\t\t},\n\n\t\tsetMouse (m) {\n\t\t\tthis.mouseData = m\n\t\t},\n\n\t\tsetTestSettings (t) {\n\t\t\tthis.testSettings = t\n\t\t},\n\n\t\tsetDialog(dialog) {\n\t\t\tthis.dialog = dialog\n\t\t},\n\n\t\tsetModel(model){\n\t\t\tthis.model = this.createInheritedModel(model);\n\t\t\tthis.model = Core.addContainerChildrenToModel(this.model)\n\t\t\tthis.initSize()\n\t\t},\n\n\t\tinitSize () {\n\t\t\tthis.previewWrapper = this.renderPreview()\n\t\t},\n\n\t\tsetSession(session,sessionID){\n\t\t\tthis.logger.log(0, \"setSession\", \"enter \" + sessionID);\n\t\t\ttry {\n\n\t\t\t\tthis.sessionID = sessionID;\n\t\t\t\tthis.session = session;\n\t\t\t\tsession.sortBy(\"time\");\n\t\t\t\tthis.events = lang.clone(session.as_array());\n\n\n\t\t\t\t/**\n\t\t\t\t * Now we have to the WidgetClick events a little and move them forward\n\t\t\t\t * if the trigger a screen transition, because otherwise the the animation\n\t\t\t\t * is deleted.\n\t\t\t\t * Also we fix ScreenGestures\n\t\t\t\t */\n\t\t\t\tfor(var i=0; i <this.events.length;i++){\n\t\t\t\t\tvar event = this.events[i];\n\t\t\t\t\tvar nextEvent = null;\n\t\t\t\t\tif(i +1 < this.events.length){\n\t\t\t\t\t\tnextEvent = this.events[i+1];\n\t\t\t\t\t\tif((nextEvent.type == \"ScreenLoaded\" || nextEvent.type == \"ScreenAnimation\") && ( event.type==\"WidgetClick\" || event.type == \"ScreenGesture\")){\n\t\t\t\t\t\t\tevent.time -= this.animationTimeOffSet;\n\t\t\t\t\t\t\tevent._transition = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Fix gestures\n\t\t\t\t */\n\t\t\t\tthis.fixGestures(this.events);\n\n\n\t\t\t\t/**\n\t\t\t\t * no check for tasks\n\t\t\t\t */\n\t\t\t\tthis.taskMatches = this.getMatches();\n\n\n\t\t\t\tthis.duration = this.session.max(\"time\") - this.session.min(\"time\");\n\t\t\t\tthis.min = this.session.min(\"time\");\n\n\n\t\t\t\t/**\n\t\t\t\t * init widget states\n\t\t\t\t */\n\t\t\t\t this.initWidgetStatesAndScroll();\n\n\n\t\t\t\t /**\n\t\t\t\t  * now build for all ui widgets a time series\n\t\t\t\t  * with the states. for every event we have to know the\n\t\t\t\t  * state of all widgets.\n\t\t\t\t  */\n\t\t\t \t this.render();\n\n\t\t\t\t /**\n\t\t\t\t  * init animations\n\t\t\t\t  */\n\t\t\t\t this.initAnimations();\n\n\n\t\t\t\t /**\n\t\t\t\t  *\n\t\t\t\t  */\n\t\t\t\t this.initMouseData();\n\n\t\t\t\t /**\n\t\t\t\t  * Start ship up\n\t\t\t\t  */\n\t\t\t\t this.lastEventPos =0;\n\t\t\t\t this.setTime(0);\n\t\t\t} catch(e){\n\t\t\t\tconsole.debug(e.err);\n\t\t\t\tconsole.debug(e.stack);\n\t\t\t}\n\n\t\t\t//console.debug(this._widgetAnimationStates)\n\n\t\t},\n\n\t\t/**\n\t\t * Transform raw array based mouse data into time based lookup table\n\t\t */\n\t\tinitMouseData(){\n\t\t\tvar maxMouse = 0;\n\t\t\tvar mouseStates = {};\n\t\t\tif(this.mouseData){\n\n\t\t\t\tvar d = this.mouseData;\n\t\t\t\tfor(var i=0; i< d.length; i++){\n\t\t\t\t\tvar batch = d[i];\n\t\t\t\t\tfor(var j=0; j < batch.t.length; j++){\n\t\t\t\t\t\tvar e = {\n\t\t\t\t\t\t\tscreen : batch.screen,\n\t\t\t\t\t\t\ttime : batch.t[j],\n\t\t\t\t\t\t\tx : batch.x[j],\n\t\t\t\t\t\t\ty : batch.y[j],\n\t\t\t\t\t\t\tdur : batch.sample\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar t  = this.getAnimationIndex(e.time-this.min);\n\t\t\t\t\t\tmouseStates[t] = e;\n\t\t\t\t\t\tmaxMouse = Math.max(e.time)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// delete this.mouseData\n\t\t\t\tthis.mouseData = null\n\t\t\t}\n\t\t\tthis._mouseStates = mouseStates;\n\t\t\tthis.duration = Math.max( maxMouse-this.min, this.duration);\n\t\t},\n\n\n\t\t/**\n\t\t * This method will loop over all events and will calculate the state for all widgets\n\t\t */\n\t\tinitAnimations(){\n\t\t\tthis.logger.log(0, \"initAnimations\", \"enter\");\n\n\t\t\t/**\n\t\t\t * we init this for all\n\t\t\t */\n\t\t\tvar aFac = new Animation();\n\n\t\t\t/**\n\t\t\t * Init lookup table... for every possible timestamp we\n\t\t\t * have a slot. In each slot we have info for each widget\n\t\t\t */\n\t\t\tthis._widgetAnimationStates = {};\n\t\t\tfor(let i=0; i< this.duration;  i+=30){\n\t\t\t\tthis._widgetAnimationStates[i] = {}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Init style holders\n\t\t\t */\n\t\t\tvar widgetInited = {};\n\t\t\tvar lastState = {};\n\t\t\tthis.styleIDCounter =0;\n\n\t\t\t/**\n\t\t\t * Init pos holders\n\t\t\t */\n\t\t\tvar lastPos = {};\n\t\t\tvar widgetInitedPos = {};\n\t\t\tthis.posIDCounter =0;\n\t\t\tvar lastScreenLoadTimeStamp = 0;\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\t// let screenID = event.screen;\n\t\t\t\t// let widgetID = event.widget;\n\t\t\t\t// let widget = this.model.widgets[widgetID];\n\t\t\t\tlet start  = this.getAnimationIndex(event.time-this.min);\n\n\t\t\t\t/**\n\t\t\t\t * Reset style because of screen load\n\t\t\t\t */\n\t\t\t\tif(( event.type ==\"ScreenLoaded\" || event.type ==\"OverlayLoaded\")){\n\n\t\t\t\t\tfor(let j=start; j < this.duration; j+=30 ){\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Reset styles and pos\n\t\t\t\t\t\t */\n\t\t\t\t\t\t// let widgets = this._widgetAnimationStates[j];\n\t\t\t\t\t\tfor(let id in widgetInited){\n\t\t\t\t\t\t\tvar orgStyle = widgetInited[id];\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][id].style = orgStyle;\n\t\t\t\t\t\t\tlastState[animWidgetId] = orgStyle;\n\n\t\t\t\t\t\t\tvar orgPos = widgetInitedPos[id];\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][id].pos = orgPos;\n\t\t\t\t\t\t\tlastPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\t\t\t\t\tlastScreenLoadTimeStamp = start;\n\t\t\t\t}\n\n\n\t\t\t\t/**\n\t\t\t\t * FIXME: Add here some Screen and Animation index! Otherwise Clicks or\n\t\t\t\t * Animations might stop the ScreenAnimation!\n\t\t\t\t */\n\t\t\t\t//if(event.type == \"ScreenAnimation\" ){\n\t\t\t\t//}\n\n\n\t\t\t\tif(event.type ==\"Animation\"){\n\t\t\t\t\t/**\n\t\t\t\t\t * The animation might have been triggered by the widgetID,\n\t\t\t\t\t * but it animated another widget, which is stored\n\t\t\t\t\t * in the event.animation.id\n\t\t\t\t\t */\n\t\t\t\t\tvar animWidgetId = event.animation.id;\n\n\t\t\t\t\tvar animWidget = this.model.widgets[animWidgetId];\n\t\t\t\t\tif(animWidget){\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * init the index with the original style as default. This should just be\n\t\t\t\t\t\t * a reference, therefore I hope it does not consume too much memory...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(!widgetInited[animWidgetId]){\n\t\t\t\t\t\t\tlet orginalStyle = this.initWidgetAnimation(animWidgetId, animWidget);\n\t\t\t\t\t\t\twidgetInited[animWidgetId] = orginalStyle;\n\t\t\t\t\t\t\tlastState[animWidgetId] = orginalStyle;\n\n\t\t\t\t\t\t\tlet orgPos = this.initWidgetAnimationPos(animWidgetId, animWidget);\n\t\t\t\t\t\t\twidgetInitedPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t\tlastPos[animWidgetId] = orgPos;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tvar animation = event.animation;\n\n\t\t\t\t\t\tvar fromStyle = animation.from.style;\n\t\t\t\t\t\tvar toStyle = animation.to.style;\n\n\n\t\t\t\t\t\tvar fromPos = animation.from.pos;\n\t\t\t\t\t\tif(fromPos){\n\t\t\t\t\t\t\tfromPos = this.getAbsolutePosition(event.screen, fromPos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar toPos = animation.to.pos;\n\t\t\t\t\t\tif(toPos){\n\t\t\t\t\t\t\ttoPos = this.getAbsolutePosition(event.screen, toPos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//console.debug(\"Animate \", start ,\"/\", this.duration , \" => \", animation.duration + start);\n\n\t\t\t\t\t\tvar animationEnded = false;\n\t\t\t\t\t\tvar mixed;\n\t\t\t\t\t\tvar mixedPos;\n\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We have here a problem. The animations are started not with the correct\n\t\t\t\t\t\t * timestamp of we have onload animations!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tvar startTimeStamp = start;\n\t\t\t\t\t\tif(event.animation && event.animation.triggerType ==\"ScreenLoaded\"){\n\t\t\t\t\t\t\tstartTimeStamp = lastScreenLoadTimeStamp;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Now calculate the state from the *start* point on.\n\t\t\t\t\t\t * j is the rolling timestamp\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfor(let j=startTimeStamp; j < this.duration; j+=30 ){\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * The current time index for the animation. We substract start,\n\t\t\t\t\t\t\t * to make it start at 0\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tlet t = j - start;\n\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Get the p\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tvar p = 1;\n\t\t\t\t\t\t\tif(animation.duration > 0){\n\t\t\t\t\t\t\t\tif(animation.delay){\n\t\t\t\t\t\t\t\t\tp = aFac.getP(t,animation.delay, animation.duration );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tp = Math.min(1, t / animation.duration);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(!animationEnded || !mixed){\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Here we call the factory to get the animated style\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tmixed  =  aFac.getAnimationMixedStyle(fromStyle,toStyle, p );\n\t\t\t\t\t\t\t\tmixed._aid = this.styleIDCounter++;\n\t\t\t\t\t\t\t\tmixed._org = false;\n\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * now mix with last state to have full state at every\n\t\t\t\t\t\t\t\t * point of time. The last state must be correctly initialized\n\t\t\t\t\t\t\t\t * with the org style!\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvar last = lastState[animWidgetId];\n\t\t\t\t\t\t\t\tfor(var key in last){\n\t\t\t\t\t\t\t\t\tif(mixed[key] == undefined){\n\t\t\t\t\t\t\t\t\t\t//console.debug(\"-\", j , \"fill : \", key, mixed[key], \" <- \", last[key])\n\t\t\t\t\t\t\t\t\t\tmixed[key] = last[key];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastState[animWidgetId] = lang.clone(mixed);\n\n\n\t\t\t\t\t\t\t\tif(fromPos && toPos){\n\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * Do calculate here the mixedPos\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tmixedPos = aFac.getAnimationMixedPos(fromPos,toPos, p );\n\t\t\t\t\t\t\t\t\tmixedPos._aid = this.posIDCounter++;\n\t\t\t\t\t\t\t\t\tmixedPos._org = false;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmixedPos = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(p >=1){\n\t\t\t\t\t\t\t\tanimationEnded = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._widgetAnimationStates[j][animWidgetId].style = mixed;\n\t\t\t\t\t\t\tif(mixedPos){\n\t\t\t\t\t\t\t\tthis._widgetAnimationStates[j][animWidgetId].pos = mixedPos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(\"initAnimations() > No widgte\", animWidgetId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * HACK: we remove now all animation so ScreenAnaimtions run through\n\t\t\t */\n\t\t\tvar temp = [];\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\tif(event.type !=\"Animation\"){\n\t\t\t\t\ttemp.push(event)\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.events = temp;\n\n\t\t\tthis.logger.log(0, \"initAnimations\", \"exit > \" + this.styleIDCounter);\n\t\t},\n\n\t\tgetAbsolutePosition(screenID, pos){\n\t\t\tvar screen = this.scaledModel.screens[screenID];\n\t\t\tif(screen){\n\t\t\t\tvar result = {\n\t\t\t\t\tx : Math.round(screen.w * pos.x),\n\t\t\t\t\ty : Math.round(screen.h * pos.y),\n\t\t\t\t\tw : Math.round(screen.w * pos.w),\n\t\t\t\t\th : Math.round(screen.h * pos.h)\n\t\t\t\t};\n\t\t\t\treturn result;\n\t\t\t}\n\t\t},\n\n\n\t\tinitWidgetAnimation(widgetID,widget ){\n\n\n\t\t\t/**\n\t\t\t * create here a copy and set and \"_aid\" id field\n\t\t\t * so we can later do the change checking faster\n\t\t\t * (oldstyle._aid == newstyle._aid).\n\t\t\t */\n\t\t\tvar orginalStyle = lang.clone(widget.style);\n\t\t\torginalStyle._aid = this.styleIDCounter++;\n\t\t\torginalStyle._org = true;\n\n\n\t\t\tfor(var j=0; j< this.duration;  j+=30){\n\t\t\t\tthis._widgetAnimationStates[j][widgetID] = {\n\t\t\t\t\tstyle :  orginalStyle\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn orginalStyle;\n\t\t},\n\n\t\tinitWidgetAnimationPos(widgetID){\n\t\t\tvar originalPos = {\n\t\t\t\tx :0,\n\t\t\t\ty: 0,\n\t\t\t\tw: 0,\n\t\t\t\th: 0,\n\t\t\t\tstart:true\n\t\t\t};\n\t\t\toriginalPos._aid = this.posIDCounter++;\n\t\t\toriginalPos._org = true;\n\n\n\t\t\tfor(var j=0; j< this.duration;  j+=30){\n\t\t\t\tif(!this._widgetAnimationStates[j][widgetID]){\n\t\t\t\t\tthis._widgetAnimationStates[j][widgetID] = {};\n\t\t\t\t}\n\t\t\t\tthis._widgetAnimationStates[j][widgetID].pos = originalPos;\n\t\t\t}\n\n\t\t\treturn originalPos;\n\t\t},\n\n\t\t/**\n\t\t * This method will loop over all events and will calculate the state for all widgets\n\t\t */\n\t\tinitWidgetStatesAndScroll(){\n\t\t\tthis.logger.log(1, \"initWidgetStatesAndScroll\", \"enter\");\n\n\t\t\t/**\n\t\t\t * we initialize with the default state of the widgets. We have an\n\t\t\t * states[screenID][widgetID][state] object. We do this because of the\n\t\t\t * radio buttons that we have to controll on a screen level...\n\t\t\t */\n\t\t\tvar lastStates = this.getDefaultStates();\n\n\t\t\tvar widgetStatesByEvent ={};\n\n\t\t\tvar overLays = [];\n\t\t\tvar overlayStatesByEvent ={};\n\n\t\t\tvar lastScroll = {\n\t\t\t\ttype:\"scroll\",\n\t\t\t\tvalue:0\n\t\t\t};\n\t\t\tvar screenScoll = {};\n\n\n\n\t\t\tfor(let i=0; i <this.events.length;i++){\n\t\t\t\tlet event = this.events[i];\n\t\t\t\tlet screenID = event.screen;\n\t\t\t\t// let eventID = event.id\n\n\t\t\t\t/**\n\t\t\t\t * 1) we clone that last state of all widgets. Then we set the state\n\t\t\t\t * for the current event to the states of the current screen!\n\t\t\t\t */\n\t\t\t\tvar states = lang.clone(lastStates)\n\t\t\t\twidgetStatesByEvent[event.id] = states[screenID];\n\t\t\t\tlastStates = states;\n\n\n\t\t\t\t/**\n\t\t\t\t * 2) if there is a new state, we update it\n\t\t\t\t * for the new state for the widget that emited it\n\t\t\t\t */\n\t\t\t\tif(event.state && event.type!=\"ScreenScroll\"){\n\n\n\t\t\t\t\tif(states[screenID]){\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * FIXME: If we do master-state-propagation, we have to update the state here, or?\n\t\t\t\t\t\t */\n\n\t\t\t\t\t\tstates[screenID][event.widget] = event.state;\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * FIXME: For the radio box we have to change  the\n\t\t\t\t\t\t * states of the other radio boxes. For now this hack is\n\t\t\t\t\t\t * ok, as I think we will only have one type of widgets with synced\n\t\t\t\t\t\t * states. Also if we have several radio button groups we have to fix\n\t\t\t\t\t\t * this...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(event.state.type == \"radiobox.checked\"){\n\t\t\t\t\t\t\tthis._setStates(states[screenID],\"radiobox.checked\", false, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(\"getWidgetStatesByEvent() > No state for screen \", screenID);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * 3) Here we build for each event the scrollPosition.\n\t\t\t\t * ScreenLoaded and ScreenAnimation will set the scrolling to 0!\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif(event.type==\"ScreenScroll\" && event.state){\n\t\t\t\t\tscreenScoll[event.id] =event.state;\n\t\t\t\t\tlastScroll = {\n\t\t\t\t\t\ttype:\"scroll\",\n\t\t\t\t\t\tvalue:event.state.value\n\t\t\t\t\t};\n\n\t\t\t\t} else if(event.type==\"ScreenLoaded\" || event.type==\"ScreenAnimation\"){\n\t\t\t\t\t/**\n\t\t\t\t\t * We set scroll to 0. Simulator does the same\n\t\t\t\t\t */\n\t\t\t\t\tvar state = {\n\t\t\t\t\t\ttype:\"scroll\",\n\t\t\t\t\t\tvalue:0\n\t\t\t\t\t};\n\t\t\t\t\tscreenScoll[event.id] =state;\n\t\t\t\t\tlastScroll = state;\n\t\t\t\t\t/**\n\t\t\t\t\t * Add here scroll state only of we do not have a ScreenAnimation.\n\t\t\t\t\t * If a ScreenLoad follows a ScreenAnimation we do not reset as well!\n\t\t\t\t\t */\n\t\t\t\t\tvar lastEvent = this.events[i-1];\n\t\t\t\t\tif (lastEvent && event.type !=\"ScreenAnimation\" && !(lastEvent.type == \"ScreenAnimation\" && event.type == \"ScreenLoaded\")) {\n\t\t\t\t\t\tif(event.scrollTop != undefined && event.scrollTop != null){\n\t\t\t\t\t\t\tstate.value = event.scrollTop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * FIXME: reset here all widget states??\n\t\t\t\t\t */\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * other events took place at the same scroll position as before\n\t\t\t\t\t */\n\t\t\t\t\tscreenScoll[event.id] = lastScroll;\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"ScreenLoaded\" ){\n\t\t\t\t\toverLays = [];\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"OverlayLoaded\"){\n\t\t\t\t\tlet index = overLays.indexOf(event.overlay);\n\t\t\t\t\tif(index <0){\n\t\t\t\t\t\toverLays.push(event.overlay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(event.type == \"OverlayShowAnimation\"){\n\t\t\t\t\tif(event.animation){\n\t\t\t\t\t\tlet index = overLays.indexOf(event.animation.to);\n\t\t\t\t\t\tif(index <0){\n\t\t\t\t\t\t\toverLays.push(event.animation.to);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.debug(\"initWidgetStatesAndScroll() > no animation for event\", event)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(event.type==\"OverlayRemoved\"){\n\t\t\t\t\tlet index = overLays.indexOf(event.overlay);\n\t\t\t\t\tif(index >-1){\n\t\t\t\t\t\toverLays.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toverlayStatesByEvent[event.id] = lang.clone(overLays);\n\t\t\t}\n\n\n\t\t\tthis._widgetStates = widgetStatesByEvent;\n\t\t\tthis._overLayStates = overlayStatesByEvent;\n\t\t\tthis._scrollStates = screenScoll;\n\n\t\t\tthis.logger.log(2, \"initWidgetStatesAndScroll\", \"exit\");\n\t\t},\n\n\n\n\n\n\n\t\t_setStates(states,type, value, event){\n\t\t\tfor(var id in states){\n\t\t\t\tvar s = states[id];\n\t\t\t\tif(s.type == type && id!= event.widget){\n\t\t\t\t\ts.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\n\n\t\t/**\n\t\t * This method gets the default state for every widget. It does this by renderibg each widget once, and calling the getState() method,\n\t\t * whoich should be corretly initialized form the UIWidget objects during rendering!\n\t\t */\n\t\tgetDefaultStates(){\n\t\t\tthis.logger.log(2, \"getDefaultStates\", \"enter\");\n\n\t\t\tvar fac = new RenderFactory();\n\t\t\tfac.setJwtToken(this.jwtToken)\n\t\t\tfac.setModel(this.model); // FIXME: Shouldn't this be zoomed?\n\t\t\tfac.setMode(\"view\");\n\t\t\tfac.setScaleFactor(1,1);\n\n\t\t\tvar dummy = document.createElement(\"div\");\n\n\t\t\tvar states = {};\n\t\t\tvar screenStates = {};\n\n\t\t\tfor(var id in this.model.widgets){\n\t\t\t\tvar widget = this.model.widgets[id];\n\t\t\t\tvar screen = this.getParentScreen(widget);\n\t\t\t\tif(screen){\n\t\t\t\t\tif(!screenStates[screen.id]){\n\t\t\t\t\t\tscreenStates[screen.id] = {};\n\t\t\t\t\t}\n\t\t\t\t\tvar uiWidget = fac.createUIWidget(dummy,  widget);\n\t\t\t\t\tif(uiWidget){\n\t\t\t\t\t\tvar state = uiWidget.getState();\n\t\t\t\t\t\tif(state){\n\t\t\t\t\t\t\t//this.logger.log(3, \"getDefaultStates\", \"State for widget '\" +id +\"' (\" + widget.name +  \") >> \" + state.type + \" :  \"+ state.value);\n\t\t\t\t\t\t\tstates[id] = state;\n\t\t\t\t\t\t\tscreenStates[screen.id][id] = state;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfac.cleanUp();\n\t\t\treturn screenStates;\n\t\t},\n\n\t\tgetMatches(){\n\n\t\t\tthis.taskNames = {};\n\t\t\tif(this.testSettings){\n\n\t\t\t\tvar session = new DataFrame(this.events);\n\t\t\t\tsession = this.getActionEvents(session);\n\n\t\t\t\tvar tasks = this.testSettings.tasks;\n\t\t\t\tfor(var i=0; i < tasks.length; i++){\n\t\t\t\t\tthis.taskNames[tasks[i].id] = tasks[i].name;\n\t\t\t\t}\n\t\t\t\treturn this.analytics.getTaskPerformance(session, tasks, true);\n\n\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tonBack(e){\n\t\t\tthis.stopEvent(e);\n\t\t\tthis.currentTime =0;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.setTime(0);\n\t\t},\n\n\t\tonPlay(e){\n\t\t\tthis.stopEvent(e);\n\n\t\t\t/**\n\t\t\t * make sure we start from the beginning after we have ended!\n\t\t\t */\n\t\t\tif(this.currentTime >= this.duration){\n\t\t\t\tthis.currentTime =0;\n\t\t\t\tthis.lastEventPos = 0;\n\t\t\t}\n\n\t\t\tif(!this.running){\n\t\t\t\tthis.start();\n\t\t\t} else {\n\t\t\t\tthis.stop();\n\t\t\t}\n\t\t},\n\n\t\tstart(){\n\t\t\tthis.running = true;\n\t\t\tcss.add(this.iconPlay, \"mdi-pause\");\n\t\t\tcss.remove(this.iconPlay, \"mdi-play\");\n\t\t\tthis.lastLoop = new Date().getTime();\n\t\t\trequestAnimationFrame(lang.hitch(this, \"loop\"));\n\t\t},\n\n\n\n\t\tstop(){\n\t\t\tthis.running = false;\n\t\t\tcss.remove(this.iconPlay, \"mdi-pause\");\n\t\t\tcss.add(this.iconPlay, \"mdi-play\");\n\t\t},\n\n\n\t\tloop(){\n\t\t\tvar now = new Date().getTime();\n\t\t\tvar dif = now - this.lastLoop;\n\t\t\tthis.lastLoop = now;\n\t\t\tthis.currentTime += dif;\n\n\n\t\t\tif(this.currentTime < this.duration){\n\t\t\t\tthis.setTime(this.currentTime);\n\t\t\t\tif(this.running){\n\t\t\t\t\trequestAnimationFrame(lang.hitch(this, \"loop\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// make sure we show the last event!\n\t\t\t\tthis.setTime(this.duration, true);\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t},\n\n\n\n\t\trender(){\n\t\t\tthis.logger.log(2,\"render\",\"enter\");\n\n\n\t\t\tthis.preview = this.$new(Preview, {isPlayer:true});\n\t\t\tthis.preview.setJwtToken(this.jwtToken)\n\t\t\tthis.preview.placeAt(this.previewWrapper);\n\t\t\tthis.preview.setModel(this.model);\n\n\t\t\tthis.scaledModel = this.preview.model;\n\n\t\t\tthis.slider = this.$new(HSlider);\n\t\t\tthis.slider.setMax(this.duration);\n\t\t\tthis.slider.setMarks(this.getAnnotation());\n\t\t\tthis.slider.placeAt(this.$refs.progress);\n\n\t\t\tthis.own(on(this.slider, \"change\", lang.hitch(this, \"onSliderChange\")));\n\t\t\tthis.renderEventList();\n\t\t\tthis.renderTaskBar()\n\t\t},\n\n\t\trenderPreview () {\n\t\t\tthis.$refs.container.innerHTML=\"\";\n\t\t\tvar previewWrapper = document.createElement(\"div\");\n\t\t\tcss.add(previewWrapper, \"MatcPlayerPreview\");\n\t\t\tthis.layout(previewWrapper);\n\t\t\treturn previewWrapper\n\t\t},\n\n\t\trenderTaskBar () {\n\t\t\tif(\tthis.taskMatches){\n\t\t\t\tconst tasks = this.taskMatches.as_dict('task')\n\t\t\t\tfor (let id in this.taskNames) {\n\t\t\t\t\tconst label = this.taskNames[id]\n\t\t\t\t\tlet row =  tasks[id]\n\t\t\t\t\tif (row) {\n\t\t\t\t\t\tconst start = (row.startTime - this.min) / this.duration\n\t\t\t\t\t\tconst length = (row.endTime - row.startTime) / this.duration\n\t\t\t\t\t\tthis.renderTask(start, length, label)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Object.values(tasks).length === 0) {\n\t\t\t\t\tcss.add(this.$refs.tasks, \"MatcHidden\")\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trenderTask (start, length, label) {\t\t\t\n\t\t\tconst bar = this.db\n\t\t\t\t.div('MatcPlayerTasksBarCntr')\n\t\t\t\t.div('MatcPlayerTasksBar', label)\n\t\t\t\t.build(this.$refs.tasks)\n\t\t\n\t\t\tbar.style.left = Math.min(97, (start * 100)) +'%'\n\t\t\tbar.style.width = Math.max(3, 100* length) +'%'\n\t\t},\n\n\n\t\tgetAnnotation(){\n\t\t\tconst result = [];\n\t\t\tif(\tthis.taskMatches){\n\t\t\t\tthis.taskMatches.foreach(row => {\n\t\t\t\t\tconst marker = {\n\t\t\t\t\t\tstart : row.startTime - this.min,\n\t\t\t\t\t\tlength : 0\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(marker);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\trenderEventList(){\n\n\t\t\t/**\n\t\t\t * Merge in annotation.tags\n\t\t\t */\n\t\t\tvar list = [];\n\t\t\tfor(let i=0; i< this.events.length; i++){\n\t\t\t\tlet e = this.events[i];\n\t\t\t\tlist.push(e);\n\t\t\t}\n\t\t\tlist.sort(function(a,b){\n\t\t\t\treturn a.time - b.time;\n\t\t\t});\n\n\t\t\tthis.eventCntr.innerHTML=\"\";\n\t\t\tthis.cleanUpTempListener();\n\n\t\t\t// var scroller = new ScrollContainer();\n\t\t\t// scroller.placeAt(this.eventCntr);\n\n\t\t\tvar parent = document.createElement(\"div\");\n\n\t\t\tfor(let i=0; i< list.length; i++){\n\t\t\t\tlet e = list[i];\n\t\t\t\tlet type = e.type;\n\t\t\t\tif(type){\n\n\t\t\t\t\tif(!this.invisibleEvents[type] && !e.hidden){\n\t\t\t\t\t\tvar item = document.createElement(\"div\");\n\t\t\t\t\t\tcss.add(item, \"MatcPlayerEvent\");\n\t\t\t\t\t\tcss.add(item, e.type);\n\t\t\t\t\t\tvar txt = this.getMinute(e.time -this.min);\n\t\t\t\t\t\tif(type == \"WidgetClick\" || type == \"WidgetChange\" || type==\"ValidationError\" || type==\"ValidationErrorLine\"){\n\t\t\t\t\t\t\tif(e.state && (type == \"WidgetClick\" || type == \"WidgetChange\" )){\n\t\t\t\t\t\t\t\ttxt += \" - \" +  this.getEventStateLabel(e.state);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet widget = this.model.widgets[e.widget];\n\t\t\t\t\t\t\tif(widget){\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + widget.name+\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + e.widget +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(type ==\"ScreenGesture\" && e.gesture){\n\t\t\t\t\t\t\tlet gesture = e.gesture;\n\t\t\t\t\t\t\tlet screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - Screen \" + this.getGestureLabel(gesture.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - Screen \" + this.getGestureLabel(gesture.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    } else if(type ==\"WidgetGesture\" && e.gesture){\n\t\t\t\t\t\t\tlet gesture = e.gesture;\n\t\t\t\t\t\t\tlet screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getGestureLabel(gesture.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getGestureLabel(gesture.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet widget = this.model.widgets[e.widget];\n\t\t\t\t\t\t\tif(widget){\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + widget.name+\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt +=\" -  &quot;\" + e.widget +\"&quot;\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t\tvar screen = this.model.screens[e.screen];\n\t\t\t\t\t\t\tif(screen){\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type) + \" -  &quot;\" + screen.name +\"&quot;\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttxt += \" - \" + this.getEventLabel(e.type) + \" - &quot;\" + e.screen +\"&quot;\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem.innerHTML= this.stripHTML(txt);\n\t\t\t\t\t\tparent.appendChild(item);\n\t\t\t\t\t\tthis.tempOwn(on(item, touch.press, lang.hitch(this, \"onEvent\", e)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet item = document.createElement(\"div\");\n\t\t\t\t\tcss.add(item, \"MatcPlayerEvent MatcPlayerTagEvent\");\n\t\t\t\t\tlet txt = this.getMinute(e.time -this.min) + \" - Tag &quot;\" + this.stripHTML( e.tag) + \"&quot;\";\n\t\t\t\t\titem.innerHTML=  txt;\n\t\t\t\t\tparent.appendChild(item);\n\t\t\t\t\tthis.tempOwn(on(item, touch.press, lang.hitch(this, \"onEvent\", e)));\n\n\t\t\t\t\tlet del = document.createElement(\"span\");\n\t\t\t\t\tcss.add(del, \"mdi mdi-close-circle MatcPlayerEventRemove\");\n\t\t\t\t\titem.appendChild(del);\n\t\t\t\t\tthis.tempOwn(on(del, touch.press, lang.hitch(this, \"removeTag\", e)));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.eventCntr.appendChild(parent)\n\t\t},\n\n\t\tlayout(previewWrapper){\n\t\t\tconst container = this.$refs.container\n\n\t\t\tconst cPos = domGeom.position(container);\n\t\t\tconst pos = this.getScaledSize(cPos, \"auto\", this.model);\n\n\t\t\tpreviewWrapper.style.width = Math.round(pos.w) + \"px\";\n\t\t\tpreviewWrapper.style.height = pos.h + \"px\";\n\t\t\tcontainer.style.height = pos.h + \"px\";\n\t\t\tcontainer.appendChild(previewWrapper);\n\n\t\t\tconst domPos = domGeom.position(this.domNode);\n\t\t\tthis.eventCntr.style.height= Math.floor(domPos.h) + \"px\";\n\n\t\t\n\n\t\t\tif (this.dialog) {\n\t\t\t\tthis.logger.log(-1,'layout', 'dialog >> ' +  domPos.h + ' x ' +  domPos.w)\n\t\t\t\tdomPos.w += 0\n\t\t\t\tdomPos.h += 0\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.dialog.resize(domPos)\n\t\t\t\t}, 30)\n\t\t\t}\t\t\n\t\t},\n\n\t\tonEvent(e){\n\t\t\tthis.currentTime = e.time - this.min;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.preview.resetAnimations();\n\t\t\tthis.setTime(this.currentTime, true);\n\t\t},\n\n\n\n\t\tonSliderChange(v){\n\t\t\tthis.currentTime = v;\n\t\t\tthis.lastEventPos = 0;\n\t\t\tthis.preview.resetAnimations();\n\t\t\tthis.setTime(v, true);\n\t\t},\n\n\t\t/**\n\t\t * Render of time t (which is relative to the end. Dunno why I did that...)\n\t\t */\n\t\tsetTime(t, forceMarker){\n\n\t\t\t/**\n\t\t\t * The widget might already be destroyed....\n\t\t\t */\n\t\t\tif(!this.time){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Show the time\n\t\t\t */\n\t\t\tthis.time.innerHTML = this.getMinute(t) + \" / \" + this.getMinute(this.duration)  + \"\";\n\t\t\tthis.slider.setValue(t);\n\n\n\t\t\t/**\n\t\t\t * Now get the event\n\t\t\t */\n\t\t\tvar event = this.getEvent(Math.floor(t));\n\n\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * Set screen or animate transition\n\t\t\t\t */\n\t\t\t\tif(event.screen){\n\n\t\t\t\t\tif(\"ScreenAnimation\" == event.type){\n\t\t\t\t\t\tthis.preview.animateScreen(event, t, this.min);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.preview.setScreen(event.screen, event.scrollTop);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Set overlays.\n\t\t\t\t *\n\t\t\t\t * 1) We render all overlays.\n\t\t\t\t * 2) Then we run an animation if required\n\t\t\t\t */\n\t\t\t\tvar overlays = this._overLayStates[event.id];\n\t\t\t\tif(overlays){\n\t\t\t\t\tthis.preview.setOverlays(overlays);\n\t\t\t\t}\n\t\t\t\tif(event.type == \"OverlayShowAnimation\" || event.type == \"OverlayRemoveAnimation\"){\n\n\t\t\t\t\tthis.preview.animateOverlay(event, t, this.min);\n\n\t\t\t\t} else if(this.lastEvent && this.lastEvent.type == \"OverlayShowAnimation\"){\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Because of skipping or so, the animation might not have reached 100%,\n\t\t\t\t\t * so we force fore the animation one mo time,\n\t\t\t\t\t */\n\t\t\t\t\tthis.preview.animateOverlay(this.lastEvent, t, this.min);\n\t\t\t\t}\n\n\n\t\t\t\t/**\n\t\t\t\t * Show a click marker. We only show the marker if the delta is small\n\t\t\t\t * and there and x and y values\n\t\t\t\t */\n\t\t\t\tvar tDelta = 0;\n\t\t\t\tif(forceMarker){\n\t\t\t\t\ttDelta = Math.abs((event.time -this.min) - t);\n\t\t\t\t}\n\t\t\t\tif(event.x> 0 && event.y >0 && tDelta < 100){\n\t\t\t\t\tthis.preview.setMarker(event, forceMarker );\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * now update widget states\n\t\t\t\t */\n\t\t\t\tvar states = this._widgetStates[event.id];\n\t\t\t\tfor(var widgetID in states){\n\t\t\t\t\tvar state = states[widgetID];\n\t\t\t\t\tthis.preview.setWidgetState(widgetID, state, forceMarker, t +this.min);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Set scroll\n\t\t\t\t */\n\t\t\t\tthis.setScroll(event, t);\n\n\t\t\t\tthis.setMouseCursor(event, t);\n\n\n\t\t\t\t/**\n\t\t\t\t * fire widget animations\n\t\t\t\t */\n\n\t\t\t\tvar at = this.getAnimationIndex(t);\n\t\t\t\tif(this._widgetAnimationStates[at]){\n\t\t\t\t\tvar animStates = this._widgetAnimationStates[at];\n\t\t\t\t\tthis.preview.setWidgetAnimationStates(animStates);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"setTime() > No animation data for time index\", at)\n\t\t\t\t}\n\n\t\t\t} catch (err) {\n\t\t\t\tconsole.warn(\"VideoPlayer.setTime() > Error\", err)\n\t\t\t}\n\t\t\t\n\n\t\t\tthis.lastEventID = event.id;\n\n\t\t\tthis.lastEvent = event;\n\t\t},\n\n\n\t\tsetMouseCursor(event, t){\n\t\t\tvar i  = this.getAnimationIndex(t);\n\n\t\t\tif(this._mouseStates && this._mouseStates[i]){\n\t\t\t\tthis.preview.setMouse(this._mouseStates[i]);\n\t\t\t}\n\n\n\t\t},\n\n\t\tsetScroll(event, t){\n\n\t\t\tvar scrollState = this._scrollStates[event.id];\n\t\t\tif(scrollState){\n\t\t\t\tif(scrollState.children){\n\t\t\t\t\tif(!scrollState._ts){\n\t\t\t\t\t\tscrollState._scrollts = this.createTimeSeries(scrollState.children)\n\t\t\t\t\t}\n\t\t\t\t\tt = t + this.min;\n\t\t\t\t\tvar scrollEvent = scrollState._scrollts.get(t); //this._getLastValueForTime(scrollState.children, t);\n\t\t\t\t\tif(scrollEvent){\n\t\t\t\t\t\tthis.preview.setScroll(scrollEvent.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.debug(\"setScroll()> No scrollEvent for event \", t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.preview.setScroll(scrollState.value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"setScroll() > No scrollState for \", event.id);\n\t\t\t}\n\n\n\t\t},\n\n\t\t_getLastValueForTime(values, t){\n\t\t\tvar result = null;\n\t\t\tif(values){\n\t\t\t\t/**\n\t\t\t\t * we now the list is ordered. So we could use binay search, and save also the last position...\n\t\t\t\t */\n\t\t\t\tfor(var i=0; i< values.length; i++){\n\t\t\t\t\tvar value = values[i];\n\t\t\t\t\tif(value.time <= t) {\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"_getLastValueForTime() > No values passed\");\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\n\t\t/**\n\t\t * This method will return the event for the time stamp. It has a little tweak that it will start from the\n\t\t * last position, so that in theory we should have in the animation loop only 1 or 2 iterations in the loop.\n\t\t * However when clicking on the slider we have to set the lastEventPos to 0 so that we search all the array.\n\t\t */\n\t\tgetEvent(t){\n\t\t\tvar event = null;\n\t\t\tfor(var i= this.lastEventPos; i < this.events.length; i++){\n\t\t\t\tvar e = this.events[i];\n\t\t\t\tvar time = e.time - this.min;\n\t\t\t\tif(time > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevent = e;\n\t\t\t\tthis.lastEventPos = i;\n\t\t\t}\n\t\t\treturn event;\n\t\t},\n\n\n\t\tgetMinute(t){\n\t\t\tvar s = Math.round(t/1000);\n\t\t\tvar min = Math.floor(s / 60);\n\t\t\tvar sec = s % 60;\n\t\t\tif(sec < 10){\n\t\t\t\tsec = \"0\"+sec;\n\t\t\t}\n\t\t\treturn min+\":\"+sec;\n\t\t}\n    },\n    mounted () {\n    }\n}\n</script>","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./VideoPlayer.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./VideoPlayer.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./VideoPlayer.vue?vue&type=template&id=3d9bb06a\"\nimport script from \"./VideoPlayer.vue?vue&type=script&lang=js\"\nexport * from \"./VideoPlayer.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","staticRenderFns","name","mixins","_Color","DojoWidget","data","defaultRadius","defaultBlur","defaultGradient","max","components","methods","computeMouseDistribution","events","model","result","screens","i","length","event","screen","push","id","screenModel","screenEvents","temp","xs","x","ys","y","ts","t","j","sort","a","b","width","w","height","h","lastT","m","e","tDif","Math","log","console","error","round","values","_matrixToData","debug","computeClickDistribution","value","noheat","row","pos","cleanUpHeat","_circle","draw","ctx","minOpacity","radius","_grad","gradient","clearRect","p","len","globalAlpha","undefined","drawImage","_r","colored","getImageData","_colorize","putImageData","r","blur","circle","document","createElement","getContext","r2","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","beginPath","arc","PI","closePath","fill","grad","canvas","createLinearGradient","addColorStop","fillStyle","fillRect","pixels","computeScrollDurationDistrubtion","visibleScreenSize","lastEventTime","lastScrollTop","type","scrollTop","state","children","floor","duration","time","computeScrollVisibiltyDistribution","lastPageLoad","pageSessions","to","drawSections","dist","logger","_ctx","_width","_height","warn","lastValue","lastY","color","mixColor","mounted","component","_vm","this","_c","_self","staticClass","ref","_m","attrs","Util","props","running","currentTime","lastEventPos","animationTimeOffSet","mode","invisibleEvents","postCreate","Logger","analytics","Analytics","jwtToken","Services","getUserService","getToken","db","DomBuilder","own","on","btnBack","touch","press","lang","hitch","btnPlay","init","app","setModel","nornalizeContainerChildEvents","eventsWithAnnimations","df","DataFrame","sessionGroup","groupBy","session","get","sessionID","mouseData","mouse","setSession","setMouse","setTestSettings","testSettings","setDialog","dialog","createInheritedModel","Core","addContainerChildrenToModel","initSize","previewWrapper","renderPreview","sortBy","clone","as_array","nextEvent","_transition","fixGestures","taskMatches","getMatches","min","initWidgetStatesAndScroll","initAnimations","initMouseData","setTime","err","stack","maxMouse","mouseStates","d","batch","dur","sample","getAnimationIndex","_mouseStates","aFac","Animation","_widgetAnimationStates","widgetInited","lastState","styleIDCounter","lastPos","widgetInitedPos","posIDCounter","lastScreenLoadTimeStamp","start","orgStyle","style","animWidgetId","orgPos","animation","animWidget","widgets","orginalStyle","initWidgetAnimation","initWidgetAnimationPos","fromStyle","from","toStyle","fromPos","getAbsolutePosition","toPos","mixed","mixedPos","animationEnded","startTimeStamp","triggerType","delay","getP","getAnimationMixedStyle","_aid","_org","last","key","getAnimationMixedPos","screenID","scaledModel","widgetID","widget","originalPos","lastStates","getDefaultStates","widgetStatesByEvent","overLays","overlayStatesByEvent","lastScroll","screenScoll","states","_setStates","lastEvent","index","indexOf","overlay","splice","_widgetStates","_overLayStates","_scrollStates","s","fac","RenderFactory","setJwtToken","setMode","setScaleFactor","dummy","screenStates","getParentScreen","uiWidget","createUIWidget","getState","cleanUp","taskNames","getActionEvents","tasks","getTaskPerformance","onBack","stopEvent","onPlay","stop","css","add","iconPlay","remove","lastLoop","Date","getTime","requestAnimationFrame","loop","now","dif","preview","$new","Preview","isPlayer","placeAt","slider","HSlider","setMax","setMarks","getAnnotation","$refs","progress","renderEventList","renderTaskBar","container","innerHTML","layout","as_dict","label","startTime","endTime","renderTask","Object","bar","div","build","left","foreach","marker","list","eventCntr","cleanUpTempListener","parent","hidden","item","txt","getMinute","getEventLabel","getEventStateLabel","gesture","getGestureLabel","stripHTML","appendChild","tempOwn","tag","del","cPos","domGeom","position","getScaledSize","domPos","domNode","setTimeout","resize","onEvent","resetAnimations","onSliderChange","v","forceMarker","setValue","getEvent","animateScreen","setScreen","overlays","setOverlays","animateOverlay","tDelta","abs","setMarker","setWidgetState","setScroll","setMouseCursor","at","animStates","setWidgetAnimationStates","lastEventID","scrollState","_ts","_scrollts","createTimeSeries","scrollEvent","_getLastValueForTime","sec"],"sourceRoot":""}